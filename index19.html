<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
	<style>
        canvas {
            border: 1px solid black;
            touch-action: none; /* Deshabilitar el desplazamiento de la pantalla táctil */
        }
    </style>
  <!-- <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.15/paper-full.min.js"></script> --> 
       <script type="text/javascript" src="./assets/js/paper-full.min.js"></script> 
</head>
<body>
<canvas id="myCanvas" width="400" height="400"></canvas>

<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function() {
    // Inicializar el canvas
    const canvas = document.getElementById('myCanvas');
    paper.setup(canvas);
    console.log("Script cargado correctamente");

    // Crear un nuevo path para el cuadrado
    let square = new paper.Path({
        strokeColor: 'black', // Agregar color negro al trazo
        strokeWidth: 2 // Agregar grosor al trazo
    });

    let startPoint = null;
    let isDrawing = false;
    let currentDirection = 'right'; // Dirección actual del dibujo
    let currentLength = 0; // Longitud actual del lado del cuadrado
    let lastPoint = null; // Último punto agregado al path
    let sides = 0; // Número de lados dibujados
    let squareSize = 140; // Tamaño del cuadrado

    let instructedSideLengths = [0, 0, 0, 0]; // Longitudes reales de cada lado
    const tolerance = 10; // Tolerancia en píxeles para validar los lados
    const minMovementThreshold = 5; // Umbral de movimiento mínimo para comenzar a dibujar

    // Detectar eventos táctiles en dispositivos táctiles
    canvas.addEventListener('touchstart', (event) => {
        event.preventDefault(); // Evitar el comportamiento de desplazamiento predeterminado
        const touch = event.touches[0];
        startPoint = new paper.Point(touch.clientX, touch.clientY);
        isDrawing = true;
        square = new paper.Path({
            strokeColor: 'black', // Agregar color negro al trazo
            strokeWidth: 2 // Agregar grosor al trazo
        });
        square.add(startPoint);
        lastPoint = startPoint;
        sides = 0;
        currentDirection = 'right';
        currentLength = 0;
        instructedSideLengths = [0, 0, 0, 0];
        const speech = new SpeechSynthesisUtterance('Hola, comienza a dibujar un cuadrado de 3cm de largo hacia la derecha');
        window.speechSynthesis.speak(speech);
    });

    canvas.addEventListener('touchmove', (event) => {
        if (isDrawing && startPoint) {
            event.preventDefault(); // Evitar el comportamiento de desplazamiento predeterminado
            const touch = event.touches[0];
            let currentPoint = new paper.Point(touch.clientX, touch.clientY);
            let delta = currentPoint.subtract(lastPoint);

            // Verificar si el movimiento supera el umbral mínimo
            if (delta.length >= minMovementThreshold) {
                if (currentDirection === 'right') {
                    if (delta.x >= 0 && delta.y < tolerance) {
                        currentLength += delta.length;
                        instructedSideLengths[sides] = currentLength;
                        square.add(currentPoint);
                        lastPoint = currentPoint;

                        if (currentLength >= squareSize) {
                            const speech = new SpeechSynthesisUtterance('Ahora sube 3cm hacia arriba');
                            window.speechSynthesis.speak(speech);
                            currentDirection = 'up';
                            currentLength = 0;
                            sides++;
                        }
                    } else {
                        isDrawing = false;
                        const speech = new SpeechSynthesisUtterance('No es la direccion correcta, vuelve a comenzar, por favor.');
                        window.speechSynthesis.speak(speech);
                    }
                } else if (currentDirection === 'up') {
                    if (delta.y <= 0 && delta.x < tolerance) {
                        currentLength += delta.length;
                        instructedSideLengths[sides] = currentLength;
                        square.add(currentPoint);
                        lastPoint = currentPoint;

                        if (currentLength >= squareSize) {
                            const speech = new SpeechSynthesisUtterance('Ahora ve 3cm hacia la izquierda');
                            window.speechSynthesis.speak(speech);
                            currentDirection = 'left';
                            currentLength = 0;
                            sides++;
                        }
                    } else {
                        isDrawing = false;
                        const speech = new SpeechSynthesisUtterance('No es la direccion correcta, vuelve a comenzar, por favor.');
                        window.speechSynthesis.speak(speech);
                    }
                } else if (currentDirection === 'left') {
                    if (delta.x <= 0 && delta.y < tolerance) {
                        currentLength += delta.length;
                        instructedSideLengths[sides] = currentLength;
                        square.add(currentPoint);
                        lastPoint = currentPoint;

                        if (currentLength >= squareSize) {
                            const speech = new SpeechSynthesisUtterance('Ahora baja 3cm hacia abajo');
                            window.speechSynthesis.speak(speech);
                            currentDirection = 'down';
                            currentLength = 0;
                            sides++;
                        }
                    } else {
                        isDrawing = false;
                        const speech = new SpeechSynthesisUtterance('No es la direccion correcta, vuelve a comenzar, por favor.');
                        window.speechSynthesis.speak(speech);
                    }
                } else if (currentDirection === 'down') {
                    if (delta.y >= 0 && delta.x < tolerance) {
                        currentLength += delta.length;
                        instructedSideLengths[sides] = currentLength;
                        square.add(currentPoint);
                        lastPoint = currentPoint;

                        if (currentLength >= squareSize) {
                            if (sides === 3 && Math.abs(currentPoint.x - startPoint.x) < tolerance && Math.abs(currentPoint.y - startPoint.y) < tolerance) {
                                let validSides = instructedSideLengths.every(length => Math.abs(length - squareSize) < tolerance);
                                if (validSides) {
                                    const speech = new SpeechSynthesisUtterance('¡Muy bien! Has dibujado un cuadrado aproximado de 3cm de lado ¡Te felicito!.');
                                    window.speechSynthesis.speak(speech);
                                } else {
                                    const speech = new SpeechSynthesisUtterance('El cuadrado no es preciso. Inténtalo de nuevo.');
                                    window.speechSynthesis.speak(speech);
                                }
                                isDrawing = false; // Finalizar dibujo
                            } else {
                                const speech = new SpeechSynthesisUtterance('Debes dibujar un cuadrado de 3cm de lado. Vuelve a comenzar, por favor.');
                                window.speechSynthesis.speak(speech);
                                isDrawing = false; // Finalizar dibujo ya que el cuadrado no es válido.
                            }
                            currentLength = 0;
                            sides++;
                        }
                    } else {
                        isDrawing = false;
                        const speech = new SpeechSynthesisUtterance('No es la direccion correcta, vuelve a comenzar, por favor.');
                        window.speechSynthesis.speak(speech);
                    }
                }
            }
        }
    });

    // Detectar eventos de clic del mouse en computadoras de escritorio
    canvas.addEventListener('mousedown', (event) => {
        startPoint = new paper.Point(event.offsetX, event.offsetY);
        isDrawing = true;
        square = new paper.Path({
            strokeColor: 'black', // Agregar color negro al trazo
            strokeWidth: 2 // Agregar grosor al trazo
        });
        square.add(startPoint);
        lastPoint = startPoint;
        sides = 0;
        currentDirection = 'right';
        currentLength = 0;
        instructedSideLengths = [0, 0, 0, 0];
        const speech = new SpeechSynthesisUtterance('Hola, comienza a dibujar un cuadrado de 3cm de largo hacia la derecha');
        window.speechSynthesis.speak(speech);
    });

    canvas.addEventListener('mousemove', (event) => {
        if (isDrawing && startPoint) {
            let currentPoint = new paper.Point(event.offsetX, event.offsetY);
            let delta = currentPoint.subtract(lastPoint);

            // Verificar si el movimiento supera el umbral mínimo
            if (delta.length >= minMovementThreshold) {
                if (currentDirection === 'right') {
                    if (delta.x >= 0 && delta.y < tolerance) {
                        currentLength += delta.length;
                        instructedSideLengths[sides] = currentLength;
                        square.add(currentPoint);
                        lastPoint = currentPoint;

                        if (currentLength >= squareSize) {
                            const speech = new SpeechSynthesisUtterance('Ahora sube 3cm hacia arriba');
                            window.speechSynthesis.speak(speech);
                            currentDirection = 'up';
                            currentLength = 0;
                            sides++;
                        }
                    } else {
                        isDrawing = false;
                        const speech = new SpeechSynthesisUtterance('No es la direccion correcta, vuelve a comenzar, por favor.');
                        window.speechSynthesis.speak(speech);
                    }
                } else if (currentDirection === 'up') {
                    if (delta.y <= 0 && delta.x < tolerance) {
                        currentLength += delta.length;
                        instructedSideLengths[sides] = currentLength;
                        square.add(currentPoint);
                        lastPoint = currentPoint;

                        if (currentLength >= squareSize) {
                            const speech = new SpeechSynthesisUtterance('Ahora ve 3cm hacia la izquierda');
                            window.speechSynthesis.speak(speech);
                            currentDirection = 'left';
                            currentLength = 0;
                            sides++;
                        }
                    } else {
                        isDrawing = false;
                        const speech = new SpeechSynthesisUtterance('No es la direccion correcta, vuelve a comenzar, por favor.');
                        window.speechSynthesis.speak(speech);
                    }
                } else if (currentDirection === 'left') {
                    if (delta.x <= 0 && delta.y < tolerance) {
                        currentLength += delta.length;
                        instructedSideLengths[sides] = currentLength;
                        square.add(currentPoint);
                        lastPoint = currentPoint;

                        if (currentLength >= squareSize) {
                            const speech = new SpeechSynthesisUtterance('Ahora baja 3cm hacia abajo');
                            window.speechSynthesis.speak(speech);
                            currentDirection = 'down';
                            currentLength = 0;
                            sides++;
                        }
                    } else {
                        isDrawing = false;
                        const speech = new SpeechSynthesisUtterance('No es la direccion correcta, vuelve a comenzar, por favor.');
                        window.speechSynthesis.speak(speech);
                    }
                } else if (currentDirection === 'down') {
                    if (delta.y >= 0 && delta.x < tolerance) {
                        currentLength += delta.length;
                        instructedSideLengths[sides] = currentLength;
                        square.add(currentPoint);
                        lastPoint = currentPoint;

                        if (currentLength >= squareSize) {
                            if (sides === 3 && Math.abs(currentPoint.x - startPoint.x) < tolerance && Math.abs(currentPoint.y - startPoint.y) < tolerance) {
                                let validSides = instructedSideLengths.every(length => Math.abs(length - squareSize) < tolerance);
                                if (validSides) {
                                    const speech = new SpeechSynthesisUtterance('¡Muy bien! Has dibujado un cuadrado aproximado de 3cm de lado ¡Te felicito!.');
                                    window.speechSynthesis.speak(speech);
                                } else {
                                    const speech = new SpeechSynthesisUtterance('El cuadrado no es preciso. Inténtalo de nuevo.');
                                    window.speechSynthesis.speak(speech);
                                }
                                isDrawing = false; // Finalizar dibujo
                            } else {
                                const speech = new SpeechSynthesisUtterance('Debes dibujar un cuadrado de 3cm de lado. Vuelve a comenzar, por favor.');
                                window.speechSynthesis.speak(speech);
                                isDrawing = false; // Finalizar dibujo ya que el cuadrado no es válido.
                            }
                            currentLength = 0;
                            sides++;
                        }
                    } else {
                        isDrawing = false;
                        const speech = new SpeechSynthesisUtterance('No es la direccion correcta, vuelve a comenzar, por favor.');
                        window.speechSynthesis.speak(speech);
                    }
                }
            }
        }
    });
});
</script>
</body>
</br>
</br>
<center>
Hacer un <a href="http://santimonia.org/accesibilidad/testing/index19.html">clic aqui</a> para ir a la versi&oacute;n con AI y reconocimiento de voz integrada testeada en PC con Google Chrome (adaptandola a dispositivos m&oacute;viles con Apache Cordova).
</br>
</br>
Nota: Para finales de las materias Perspectivas Filos&oacute;fico Pedag&oacute;gico II y Perspectiva Pedag&oacute;gico Did&aacute;ctica II. App en desarrollo.</center>
</html>